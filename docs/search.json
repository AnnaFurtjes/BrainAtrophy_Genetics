[
  {
    "objectID": "age_corrs.html",
    "href": "age_corrs.html",
    "title": "Age-associated brain shrinkage",
    "section": "",
    "text": "Results produced by the code below are described in the manuscript under section:\nMeasures of LBA indicated age-associated brain shrinkage.\nThe traits used for correlation analysis were derived using code displayed in ‘Data preparation’: UKB: neuroimaging & phenotypic data.."
  },
  {
    "objectID": "age_corrs.html#read-in-all-samples",
    "href": "age_corrs.html#read-in-all-samples",
    "title": "Age-associated brain shrinkage",
    "section": "Read in all samples",
    "text": "Read in all samples\n\n\nCode\n# UKB - use cross-sectional data we're also using for GWAS\nUKB = fread(paste0(wd, \"/UKB_CrossNeuroIDP_noOutliers.txt\"))\nage = fread(paste0(wd, \"/UKB_covarGWAS.txt\"))\nUKB = merge(UKB, age[,c(\"FID\", \"age\",\"sex\")], by = \"FID\")\nUKB$Sample = \"UKB\"\nnames(UKB)[which(names(UKB) == \"IID\")] = \"ID\"\nnames(UKB)[which(names(UKB) == \"age\")] = \"Age\"\n\n# restrict to fam file\nfam = fread(paste0(wd, \"/ukb_neuroimaging_brainAtrophy_GWASinput.fam\"))\nUKB = UKB[UKB$FID %in% fam$V1,]\n\n# for more intuitive interpretation, we will flip the associations for resid and ratio sscore\n# larger score = more atrophy\nUKB$resid = UKB$resid*(-1)\nUKB$resid_stand = UKB$resid_stand*(-1)\nUKB$ratio = UKB$ratio*(-1)\nUKB$ratio_stand = UKB$ratio_stand*(-1)\n\n#####################\n## Human Connectome Project\n#####################\n# read in HCP data\nHCP = fread(paste0(wd,\"/unrestricted_hcp_freesurfer.csv\"))\nHCP = HCP[,c(\"Subject\", \"Gender\", \"FS_InterCranial_Vol\", \"FS_BrainSeg_Vol_No_Vent\")]\nnames(HCP) = c(\"ID\", \"Sex\", \"ICV\", \"TBV\")\n\n# add age information\nHCPage = fread(paste0(wd, \"/RESTRICTED_annafurtjes_12_14_2023_4_18_2.csv\"))\nnames(HCPage)[which(names(HCPage) == \"Subject\")] = \"ID\"\nnames(HCPage)[which(names(HCPage) == \"Age_in_Yrs\")] = \"Age\"\nHCP = merge(HCP, HCPage[,c(\"ID\",\"Age\")], by = \"ID\")\n\n# as outlined elsewhere, empirical investigations warrant to use an age cut-off of 31 years in this sample\nHCP = HCP[which(HCP$Age <= 31),]\n\n# convert mm3 estimates to more intuitive cm3 estimates\nHCP$ICV = HCP$ICV/1000\nHCP$TBV = HCP$TBV/1000\n\n# estimate brain atrophy from single MRI scan\nHCP$diff = HCP$ICV - HCP$TBV\nHCP$ratio = HCP$TBV / HCP$ICV\n\n# Quality control: \n#print(paste0(\"Some participants have negative difference scores and ratio scores > 1, which means that their ICV estimate is smaller than their TBV estimate. This must be an error as the skull always surrounds the brain. Those \", sum((HCP$diff < 0)),\" HCP participants were excluded from the data set.\"))\n\ndeletedHCP = sum(HCP$diff < 0)\n# delete those from data \nif(sum(HCP$diff < 0) != 0){HCP=HCP[-which(HCP$diff < 0),]}\n\n# estimate residual model\nmodel <- lm(TBV ~ ICV, data = HCP)\nHCP$resid = as.vector(resid(model, na.rm=T))\n\n# for more intuitive interpretation, we will flip the associations for resid and ratio sscore\n# larger score = more atrophy\nHCP$resid = HCP$resid*(-1)\nHCP$ratio = HCP$ratio*(-1)\n\n# standardise variables\nHCP$diff_stand = as.vector(scale(HCP$diff))\nHCP$ratio_stand = as.vector(scale(HCP$ratio))\nHCP$resid_stand = as.vector(scale(HCP$resid))\n\n\n#####################\n## MRi-Share\n#####################\n# read in MRi-Share\nShare = fread(paste0(wd, \"/MRiShare_global_IDPs_BSAF2021.csv\"))\nShare$TBV = Share$SPM_GM_Volume + Share$SPM_WM_Volume\nShare = Share[,c(\"ID\", \"Age\", \"Sex\", \"eTIV\", \"TBV\")]\nnames(Share) = c(\"ID\", \"Age\", \"Sex\", \"ICV\", \"TBV\")\n\n# convert mm3 estimates to more intuitive cm3 estimates\nShare$ICV = Share$ICV/1000\nShare$TBV = Share$TBV/1000\n\n# estimate brain atrophy from single MRI scan\nShare$diff = Share$ICV - Share$TBV\nShare$ratio = Share$TBV / Share$ICV\n\nmodel <- lm(TBV ~ ICV, data = Share)\nShare$resid = resid(model)\n\n# save intercept value from the regression\nShareintercept = summary(model)$coefficients[1,1]\n\n# for more intuitive interpretation, we will flip the associations for resid and ratio sscore\n# larger score = more atrophy\nShare$resid = Share$resid*(-1)\nShare$ratio = Share$ratio*(-1)\n\n# standardise variables\nShare$diff_stand = as.vector(scale(Share$diff))\nShare$ratio_stand = as.vector(scale(Share$ratio))\nShare$resid_stand = as.vector(scale(Share$resid))"
  },
  {
    "objectID": "age_corrs.html#calculate-age-correlations-and-plot",
    "href": "age_corrs.html#calculate-age-correlations-and-plot",
    "title": "Age-associated brain shrinkage",
    "section": "Calculate age correlations and plot",
    "text": "Calculate age correlations and plot\n\n\nCode\n# determine age cut-offs to iterate through\nageCut = seq(from = 22, to = max(Share$Age), by = 1)\n  \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotShare = successivelyReduceAge(data = Share, ageCut = ageCut)\n\npShare = ggplot(data = agePlotShare)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 27, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(21, 35), breaks = seq(from = 20, to = 36, by = 2))+\n  scale_x_continuous(limits = c(-0.1, 0.2), breaks = seq(from = -0.5, to = 0.35, by = 0.1))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"MRi-Share (N = \", nrow(Share),\")\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n# determine age cut-offs to iterate through\nageCut = seq(from = 23, to = max(HCP$Age), by = 1)\n \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nsuccessivelyYoungertHCP = successivelyReduceAge(data = HCP, ageCut = ageCut)\n\npHCP = ggplot(data = successivelyYoungertHCP)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 29, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(22, 31.5), breaks = seq(from = 20, to = 36, by = 2))+\n  scale_x_continuous(limits = c(-0.2, 0.3), breaks = seq(from = -0.5, to = 0.35, by = 0.1))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"HCP (N = \", nrow(HCP),\")\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n\n#### UKB\nif(mean(UKB$Age > 100)){UKB$Age = UKB$Age /12}\n# determine age cut-offs to iterate through\nageCut = seq(from = 47, to = max(UKB$Age), by = 1)\n  \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotUKB= successivelyReduceAge(data = UKB, ageCut = ageCut)\n\npUKB = ggplot(data = agePlotUKB)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(46, 84.5), breaks = seq(from = 44, to = 84, by = 2))+\n  scale_x_continuous(limits = c(-0.5, 0.5), breaks = seq(from = -0.5, to = 0.5, by = 0.2))+\n  ggtitle(paste0(\"UKB (N = \", nrow(UKB),\")\"))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n# determine age cut-offs to iterate through\nageCut = seq(from = 35, to = max(STRADL$Age), by = 1)\n  \n\n########\n# change direction STRADL\nSTRADL$resid <- STRADL$resid*(-1)\nSTRADL$ratio <- STRADL$ratio*(-1)\n\n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotSTRADL = successivelyReduceAge(data = STRADL, ageCut = ageCut)\n\npSTRADL = ggplot(data = agePlotSTRADL)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 27, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(34.5, 84.5), breaks = seq(from = 34, to = 84, by = 4))+\n  scale_x_continuous(limits = c(-0.5, 0.5), breaks = seq(from = -0.5, to = 0.5, by = 0.2))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"STRADL (N = \", nrow(STRADL),\")\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\nggsave(\"Fig3_indiv.jpg\", bg = \"white\",plot = newFig2bottoM, width = 30, height = 12, units = \"cm\", dpi = 150)"
  },
  {
    "objectID": "age_corrs.html#repeat-for-males-and-females-separately",
    "href": "age_corrs.html#repeat-for-males-and-females-separately",
    "title": "Age-associated brain shrinkage",
    "section": "Repeat for males and females separately",
    "text": "Repeat for males and females separately\nPlots generated below are in Supplementary Plot 13.\n\nFemales\n\n\nCode\n###### FEMALES\n# determine age cut-offs to iterate through\nageCut = seq(from = 22, to = max(Share$Age), by = 1)\n  \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotShare = successivelyReduceAge(data = Share[which(Share$Sex == \"F\"),], ageCut = ageCut)\n\npShareF = ggplot(data = agePlotShare)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 27, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(21, 35), breaks = seq(from = 20, to = 36, by = 2))+\n  scale_x_continuous(limits = c(-0.1, 0.2), breaks = seq(from = -0.5, to = 0.35, by = 0.1))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"MRi-Share\\n(N = \", nrow(Share[which(Share$Sex == \"F\"),]),\" females)\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n# determine age cut-offs to iterate through\nageCut = seq(from = 23, to = max(HCP$Age), by = 1)\n \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nsuccessivelyYoungertHCP = successivelyReduceAge(data = HCP[which(HCP$Sex == \"F\")], ageCut = ageCut)\n\npHCPF = ggplot(data = successivelyYoungertHCP)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 29, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(22, 31.5), breaks = seq(from = 20, to = 36, by = 2))+\n  scale_x_continuous(limits = c(-0.3, 0.6), breaks = seq(from = -0.3, to = 0.6, by = 0.2))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"HCP\\n(N = \", nrow(HCP[which(HCP$Sex == \"F\")]),\" females)\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n\n#### UKB\nif(mean(UKB$Age > 100)){UKB$Age = UKB$Age /12}\n# determine age cut-offs to iterate through\nageCut = seq(from = 47, to = max(UKB$Age), by = 1)\n  \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotUKB= successivelyReduceAge(data = UKB[UKB$sex == 1,], ageCut = ageCut)\n\npUKBF = ggplot(data = agePlotUKB)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(46, 84.5), breaks = seq(from = 44, to = 84, by = 2))+\n  scale_x_continuous(limits = c(-0.5, 0.5), breaks = seq(from = -0.5, to = 0.5, by = 0.2))+\n  ggtitle(paste0(\"UKB\\n(N = \", nrow(UKB[UKB$sex == 1,]),\" females)\"))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n# determine age cut-offs to iterate through\nageCut = seq(from = 35, to = max(STRADL$Age), by = 1)\n  \n\n########\n# change direction STRADL\n#STRADL$resid <- STRADL$resid*(-1)\n#STRADL$ratio <- STRADL$ratio*(-1)\n\n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotSTRADL = successivelyReduceAge(data = STRADL[STRADL$Sex == 0,], ageCut = ageCut)\n\npSTRADLF = ggplot(data = agePlotSTRADL)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 27, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(34.5, 84.5), breaks = seq(from = 34, to = 84, by = 4))+\n  scale_x_continuous(limits = c(-0.5, 0.5), breaks = seq(from = -0.5, to = 0.5, by = 0.2))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"STRADL\\n(N = \", nrow(STRADL[STRADL$Sex == 0,]),\" females)\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n\nAgecorrFEMALES = ggarrange(pShareF, pHCPF, pUKBF, pSTRADLF, labels = c(\"A\",\"B\",\"C\",\"D\"), common.legend = T, legend = \"bottom\", nrow=1)\nggsave(\"AgeCorr_FEMALES.jpg\", bg = \"white\",plot = AgecorrFEMALES, width = 30, height = 12, units = \"cm\", dpi = 150)\n\n\n\n\n\n\n\n\n\nMales\n\n\nCode\n###### MALES\n# determine age cut-offs to iterate through\nageCut = seq(from = 22, to = max(Share$Age), by = 1)\n  \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotShare = successivelyReduceAge(data = Share[which(Share$Sex == \"M\"),], ageCut = ageCut)\n\npShareM = ggplot(data = agePlotShare)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 27, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(21, 35), breaks = seq(from = 20, to = 36, by = 2))+\n  scale_x_continuous(limits = c(-0.2, 0.2), breaks = seq(from = -0.5, to = 0.35, by = 0.1))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"MRi-Share\\n(N = \", nrow(Share[which(Share$Sex == \"M\"),]),\" males)\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n# determine age cut-offs to iterate through\nageCut = seq(from = 23, to = max(HCP$Age), by = 1)\n \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nsuccessivelyYoungertHCP = successivelyReduceAge(data = HCP[which(HCP$Sex == \"M\")], ageCut = ageCut)\n\npHCPM = ggplot(data = successivelyYoungertHCP)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 29, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(22, 31.5), breaks = seq(from = 20, to = 36, by = 2))+\n  scale_x_continuous(limits = c(-0.3, 0.6), breaks = seq(from = -0.3, to = 0.6, by = 0.2))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"HCP\\n(N = \", nrow(HCP[which(HCP$Sex == \"M\")]),\" males)\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n\n#### UKB\nif(mean(UKB$Age > 100)){UKB$Age = UKB$Age /12}\n# determine age cut-offs to iterate through\nageCut = seq(from = 48, to = max(UKB$Age), by = 1)\n  \n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotUKB= successivelyReduceAge(data = UKB[UKB$sex == 0,], ageCut = ageCut)\n\npUKBM = ggplot(data = agePlotUKB)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(48, 84.5), breaks = seq(from = 44, to = 84, by = 2))+\n  scale_x_continuous(limits = c(-0.55, 0.6), breaks = seq(from = -1, to = 0.9, by = 0.2))+\n  ggtitle(paste0(\"UKB\\n(N = \", nrow(UKB[UKB$sex == 0,]),\" males)\"))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\n# determine age cut-offs to iterate through\nageCut = seq(from = 35, to = max(STRADL$Age), by = 1)\n  \n\n########\n# change direction STRADL\n#STRADL$resid <- STRADL$resid*(-1)\n#STRADL$ratio <- STRADL$ratio*(-1)\n\n# use function to successively reduce age and determine the correlation between age and atrophy measures\nagePlotSTRADL = successivelyReduceAge(data = STRADL[STRADL$Sex == 1,], ageCut = ageCut)\n\npSTRADLM = ggplot(data = agePlotSTRADL)+\n  geom_point(aes(x = Cor, y = `Age cut-off value`, colour = Measure), alpha = 0.5)+\n  geom_errorbar(aes(y = `Age cut-off value`, xmin = ci_l, xmax = ci_u, colour = Measure), alpha = 0.3)+\n  geom_vline(xintercept = 0, color = \"grey\")+\n  #geom_hline(yintercept = 27, color = \"grey\")+\n  xlab(\"Lifetime brain atrophy\\ncorrelation with age\")+\n  ylab(\"Maximum age in subset\\n(cut-off in age in years)\")+\n  scale_y_continuous(limits = c(34.5, 84.5), breaks = seq(from = 34, to = 84, by = 4))+\n  scale_x_continuous(limits = c(-0.7, 0.55), breaks = seq(from = -1, to = 0.55, by = 0.2))+\n  scale_color_manual(values = c(\"#D81B60\",\"#FFC107\",\"#004D40\"))+\n  ggtitle(paste0(\"STRADL\\n(N = \", nrow(STRADL[STRADL$Sex == 1,]),\" males)\"))+\n  theme_bw()+\n  theme(panel.border = element_blank())\n\nAgecorrMALES = ggarrange(pShareM, pHCPM, pUKBM, pSTRADLM, labels = c(\"A\",\"B\",\"C\",\"D\"), common.legend = T, legend = \"bottom\", nrow=1)\nggsave(\"AgeCorr_MALES.jpg\", bg = \"white\",plot = AgecorrMALES, width = 30, height = 12, units = \"cm\", dpi = 150)"
  },
  {
    "objectID": "age_corrsLBC.html",
    "href": "age_corrsLBC.html",
    "title": "Lifetime brain atrophy increases with age within individuals in LBC1936",
    "section": "",
    "text": "This analysis was moved to the Supplement during revisions of the paper. It shows that measures of lifetime brain atrophy worsen over a 9-year period in LBC1936, even when we cross-sectionally process our neuroimaging data (as opposed to using FS longitudinal processing).\nNeuroimaging data used here was prepared using code displayed in ‘Data preparation’: LBC: neuroimaging data."
  },
  {
    "objectID": "age_corrsLBC.html#read-in-data",
    "href": "age_corrsLBC.html#read-in-data",
    "title": "Lifetime brain atrophy increases with age within individuals in LBC1936",
    "section": "Read in data",
    "text": "Read in data\n\n\nCode\n# get cross-sectionally processed data from \n# wave 1\nwave1 = fread(paste0(wd, \"/LBC1936_crossNeuroWave1.txt\"))\nwave1$wave = \"wave 2\"\nwave1$age = 73\n# wave 2\nwave2 = fread(paste0(wd, \"/LBC1936_crossNeuroWave2.txt\"))\nwave2$wave = \"wave 3\"\nwave2$age = 76\n# wave 3\nwave3 = fread(paste0(wd, \"/LBC1936_crossNeuroWave3.txt\"))\nwave3$wave = \"wave 4\"\nwave3$age = 79\n# wave 4\nwave4 = fread(paste0(wd, \"/LBC1936_crossNeuroWave4.txt\"))\nwave4$wave = \"wave 5\"\nwave4$age = 82\n\n# rbind wave data\nall = rbind(wave1, wave2, wave3, wave4)\n\n# only keep participants who have all measurement points\nsave = table(all$lbc36no) == 4\nIDs = dimnames(save)[[1]][as.vector(save)]\nall = all[all$lbc36no %in% IDs,]\n\n#### later edit: so far this data has a residual score for each of the visits meaning that there can never be an increase with age in the residual score\n# Hence, here we standardise across all waves to be able to compare different time points\n# estimate residual model\nmodel <- lm(TBV ~ ICV, data = all)\nall$residALL = as.vector(resid(model, na.rm=T))"
  },
  {
    "objectID": "age_corrsLBC.html#plot-trajectories",
    "href": "age_corrsLBC.html#plot-trajectories",
    "title": "Lifetime brain atrophy increases with age within individuals in LBC1936",
    "section": "Plot trajectories",
    "text": "Plot trajectories\nThis is now Supplementary Figure 12.\n\n\nCode\np_diff = plotTraject(dat = all, y = \"diff\", col = \"#D81B60\") + \n  ggtitle(\"Raw difference score\")+\n  ylab(\"<- less atrophy         more atrophy ->\")\n\np_ratio = plotTraject(dat = all, y = \"ratio\", col = \"#FFC107\") + \n  ggtitle(\"Raw ratio score\") + \n  scale_y_reverse() + \n  ylab(\"<- less atrophy         more atrophy ->\")\n\np_resid = plotTraject(dat = all, y = \"residALL\", col = \"#004D40\") + \n  ggtitle(\"Raw residual score\")+ \n  scale_y_reverse()+ \n  ylab(\"<- less atrophy         more atrophy ->\")\n\n#cowplot::plot_grid(p_diff, p_ratio, p_resid, nrow = 1, labels = c(\"A\", \"B\", \"C\"), label_size = 6, rel_widths = c(1,1,1))\n## overall title: \"Estimated brain atrophy in LBC1936 (cross-sectional processing)\"\nplot = (p_diff | p_ratio | p_resid) + \n    plot_annotation(title = \"Lifetime brain atrophy\\n(estimated from cross-sectionally processed measures of TBV and ICV)\", \n                    tag_levels = \"A\",\n                            theme = theme(plot.tag = element_text(face = \"bold\"),\n                                  plot.title = element_text(face = \"bold\", size = 20, hjust = 0.5)))\n\nggsave(\"EstimatedAtrophy_LBC1936_wave2to5.jpg\", bg = \"white\",plot = plot, width = 35, height = 20, units = \"cm\", dpi = 150)"
  },
  {
    "objectID": "GWAS.html",
    "href": "GWAS.html",
    "title": "Genome-wide association study",
    "section": "",
    "text": "GWAS analysis was performed with the REGENIE software.\nEnsure that the resid_stand variable was calculated in the subsample with non-missing data that is analysed in the GWAS analysis."
  },
  {
    "objectID": "GWAS.html#regenie-step-1",
    "href": "GWAS.html#regenie-step-1",
    "title": "Genome-wide association study",
    "section": "Regenie: Step 1",
    "text": "Regenie: Step 1\n\n\nCode\n#!/bin/bash\n\nregenie_v3.4 \\\n--step 1 \\\n--bed $genotype/ukb_neuroimaging_brainAtrophy_GWASinput \\\n--phenoFile $phenotype/UKB_CrossNeuroIDP_noOutliers.txt \\\n--phenoColList ${trait}  \\\n--covarFile $phenotype/UKB_covarGWAS.txt \\\n--catCovarList sex,assessmentMonth,site,array,batch \\\n--bsize 100 \\\n--threads 30 \\\n--maxCatLevels 106 \\\n--lowmem \\\n--lowmem-prefix ${wd}/tmp_noOutliers \\\n--iid-only \\\n--out ${wd}/Step1_out_all_noOutliers"
  },
  {
    "objectID": "GWAS.html#regenie-step-2",
    "href": "GWAS.html#regenie-step-2",
    "title": "Genome-wide association study",
    "section": "Regenie: Step 2",
    "text": "Regenie: Step 2\n\n\nCode\n#!/bin/bash\n\nregenie_v3.4 \\\n--step 2 \\\n--bgen $imputed/ukb_chr${CHR}_clean_v3.bgen \\\n--sample $sampleFile/ukb10279_imp_chr${CHR}_v3_s487395.sample \\\n--keep $genotype/ukb_neuroimaging_brainAtrophy_GWASinput.fam \\\n--covarFile $phenotype/UKB_covarGWAS.txt \\\n--catCovarList sex,assessmentMonth,site,array,batch \\\n--maxCatLevels 106 \\\n--phenoFile $phenotype/UKB_CrossNeuroIDP_noOutliers.txt \\\n--phenoColList ${trait} \\\n--bsize 400 \\\n--minINFO 0.4 \\\n--minMAC 5 \\\n--threads 5 \\\n--pred ${step1}/Step1_out_all_pred_noOutliers.list \\\n--out $wd/GWAS_${trait}_chr${CHR}"
  },
  {
    "objectID": "GWAS.html#regenie-interaction-models-step-2",
    "href": "GWAS.html#regenie-interaction-models-step-2",
    "title": "Genome-wide association study",
    "section": "Regenie interaction models: step 2",
    "text": "Regenie interaction models: step 2\nAs unintuitive as it may seem, you must standardise the age variable before running this script. Regenie calculates a product-wise variable for the interaction between phenotype and age and if age is indicated in months or even days, the variable will be so large that regenie cannot handle it, and results will be massively inflated (results are complete nonsense with every SNP being extremely significant).\n\n\nCode\n#!/bin/bash\n\n# note that this script only runs when linked to the bgen sample file \n\ntrait=$1\n\nfor CHR in {1..22}\ndo\nregenie_v3.4 \\\n--step 2 \\\n--bgen $imputed/ukb_chr${CHR}_clean_v3.bgen \\\n--ref-first \\\n--sample $sampleFile/ukb10279_imp_chr${CHR}_v3_s487395.sample \\\n--keep $genotype/ukb_neuroimaging_brainAtrophy_GWASinput.fam \\\n--covarFile $phenotype/UKB_covarGWAS.txt \\\n--catCovarList sex,assessmentMonth,site,array,batch \\\n--maxCatLevels 106 \\\n--phenoFile $phenotype/UKB_CrossNeuroIDP_noOutliers.txt \\\n--phenoColList ${trait} \\\n--bsize 400 \\\n--minINFO 0.4 \\\n--minMAC 5 \\\n--threads 5 \\\n--gz \\\n--interaction age \\\n--pred ${step1}/Step1_out_all_noOutliers_pred.list \\\n--out $wd/GWAS_${trait}_chr${CHR}_interaction\ndone"
  },
  {
    "objectID": "GWAS.html#format-gwas-data",
    "href": "GWAS.html#format-gwas-data",
    "title": "Genome-wide association study",
    "section": "Format GWAS data",
    "text": "Format GWAS data\n\n\nCode\nlibrary(data.table)\nlibrary(stringr)\n\n# Read in the files for each area and merge them \nall_traits<-c(\"resid_stand\",\"ratio_stand\",\"diff_stand\",\"TBVstand\",\"ICVstand\",\"CSFstand\")\n\nfor(i in all_traits){\n\n    # list all files that belong to this trait\n    fileNames = list.files(pattern = i) \n    fileNames = fileNames[grepl(\".regenie.gz\", fileNames)]\n    \n\n    # exclude the 'interaction' GWAS\n    fileNames = fileNames[!grepl(\"_interaction_\", fileNames)]\n    # include the 'interaction' GWAS\n    #fileNames = fileNames[grepl(\"_interaction_\", fileNames)]\n\n    # sex split analyses\n    #fileNames<-fileNames[grepl(\"_males\", fileNames)]\n    #i = paste0(i,\"_males\")\n\n    # count number of chromosomes\n    if(length(fileNames) != 22){warning(paste0(i, \" GWAS has not got exactly 22 chromosome files!\"))}\n\n    # set object to count number of rows to 0\n    count_rows<-0\n    \n    # object to hold GWAS\n    dat <- data.frame()    \n\n     for(j in fileNames){\n            \n       print(j)\n\n        # read in file\n       file<-fread(j,header=T,data.table=F)\n\n        # if this is an interaction test, only keep interaction row for each SNP\n        if(grepl(\"interaction\", j)){\n            \n            # pull out the interaction effect from the full model\n            file <- file[grepl(\"SNPxage\", file$TEST),] \n\n            # if we're interested to look at attenuation of SNP effects, we can pull out ADD_INT_SNP which should represent the main effect of the tested SNP in the interaction model\n            #file <- file[grepl(\"INT_SNP\", file$TEST),] \n            # remove SNPxage\n            #file <- file[!grepl(\"SNPxage\", file$TEST),]\n        }\n\n        # merge\n        dat <- rbind(dat, file) \n       \n        # count number of rows \n        count_rows<-count_rows+nrow(file)\n     }\n    \n    print(\"Done merging chromosome files\")\n    \n    ## Sanity checks: Does the resulting file have the expected dimensions?\n    if(nrow(dat)!= count_rows){print(\"Resulting merged file does not match the expected numeber of rows\");break}\n    \n    if(ncol(dat) != 14){print(\"Resulting merged files does not match the expected number of columns\"); break}\n    \n    print(\"File has dimensions as expected\")\n    print(dim(dat))\n    \n    # transform pvalues from log transformation to regular\n    # https://www.biostars.org/p/358046/\n    dat$P<-10^(-dat$LOG10P)\n    #if(min(dat$P,na.rm=T)<=0 | max(dat$P,na.rm=T) >= 1){\"Transformed p-value is out of bounds\"; break}\n    summary(dat$P)\n\n    print(\"Done transform p-value column, and p-values are between 0 and 1\")\n\n    # create MAF column\n    dat$MAF<-ifelse(dat$A1FREQ < 0.5, dat$A1FREQ, 1-dat$A1FREQ)\n\n    # remove EXTRA column because it's empty\n    dat$EXTRA <- NULL\n\n    print(paste0(\"This is the file head for \",i))\n    print(head(dat))\n    \n    # define file name to save the merged file\n    fileName <- paste0(\"/CCACE_Shared/Anna_F/BrainAtrophy/data/regenie_out/finalGWAS/GWAS_brainAtrophy_\", i,\"_N43110.gz\")\n    \n    # if this is an interaction run, name accordingly}               \n    if(grepl(\"interaction\", j)){\n        #fileName <- paste0(wd,\"/GWAS_brainAtrophy_\", i,\"_attenuatedMainEffects_N43110.gz\")\n        fileName <- paste0(wd,\"/GWAS_brainAtrophy_\", i,\"_SNPxage_N43110.gz\")\n    }\n\n    # save merged file\n    fwrite(dat, fileName, na = \"NA\", quote = F, sep = \"\\t\", row.names = FALSE, col.names = TRUE)\n    \n    print(paste0(\"Done writing file for \", i))\n}\n\nprint(\"Done all traits\")"
  },
  {
    "objectID": "GWAS.html#manhattan-plot",
    "href": "GWAS.html#manhattan-plot",
    "title": "Genome-wide association study",
    "section": "Manhattan plot",
    "text": "Manhattan plot\nThe scripts below were used to make Figure 4 in the main paper, and Supplementary Plots 15-19.\n\nAlter Manhattan function for better looking annotation\nThis function was saved in a file called manhattan_big.R to be read in with source(manhattan_big.R) in the next step.\n\n\nCode\nmanhattan_big <- function(x, chr=\"CHR\", bp=\"BP\", p=\"P\", snp=\"SNP\", \n                      col=c(\"gray10\", \"gray60\"), chrlabs=NULL,\n                      suggestiveline=-log10(1e-5), genomewideline=-log10(5e-8), \n                      highlight=NULL, logp=TRUE, annotatePval = NULL, annotateTop = TRUE, ...) {\n\n    # Not sure why, but package check will warn without this.\n    CHR=BP=P=index=NULL\n    \n    # Check for sensible dataset\n    ## Make sure you have chr, bp and p columns.\n    if (!(chr %in% names(x))) stop(paste(\"Column\", chr, \"not found!\"))\n    if (!(bp %in% names(x))) stop(paste(\"Column\", bp, \"not found!\"))\n    if (!(p %in% names(x))) stop(paste(\"Column\", p, \"not found!\"))\n    ## warn if you don't have a snp column\n    if (!(snp %in% names(x))) warning(paste(\"No SNP column found. OK unless you're trying to highlight.\"))\n    ## make sure chr, bp, and p columns are numeric.\n    if (!is.numeric(x[[chr]])) stop(paste(chr, \"column should be numeric. Do you have 'X', 'Y', 'MT', etc? If so change to numbers and try again.\"))\n    if (!is.numeric(x[[bp]])) stop(paste(bp, \"column should be numeric.\"))\n    if (!is.numeric(x[[p]])) stop(paste(p, \"column should be numeric.\"))\n    \n    # Create a new data.frame with columns called CHR, BP, and P.\n    # d=data.frame(CHR=x[[chr]], BP=x[[bp]], P=x[[p]], pos = NA, index = NA) # with millions of SNPs, create dataframe at once \n                                                             #  rather than dynamically allocated(see line 72-73, and remove line 87 and line 91 )\n    \n    # If the input data frame has a SNP column, add it to the new data frame you're creating.\n    if (!is.null(x[[snp]])) d = data.frame(CHR=x[[chr]], BP=x[[bp]], P=x[[p]], pos = NA, index = NA ,SNP=x[[snp]], stringsAsFactors = FALSE) else \n        d = data.frame(CHR=x[[chr]], BP=x[[bp]], P=x[[p]], pos = NA, index = NA)\n        \n    \n    # Set positions, ticks, and labels for plotting\n    ## Sort and keep only values where is numeric.\n    #d <- subset(d[order(d$CHR, d$BP), ], (P>0 & P<=1 & is.numeric(P)))\n    #  d <- subset(d, (is.numeric(CHR) & is.numeric(BP) & is.numeric(P)))       ## unused, all three variables are numeric, line:63-65 \n    d <- d[order(d$CHR, d$BP), ]\n    #d$logp <- ifelse(logp, yes=-log10(d$P), no=d$P)\n    if (logp) {\n        d$logp <- -log10(d$P)\n    } else {\n        d$logp <- d$P\n    }\n   # d$pos=NA\n    \n    \n    # Fixes the bug where one chromosome is missing by adding a sequential index column.\n   # d$index=NA\n   # ind = 0\n   # for (i in unique(d$CHR)){\n   #     ind = ind + 1\n   #     d[d$CHR==i,]$index = ind\n   # }\n   d$index = rep.int(seq_along(unique(d$CHR)), times = tapply(d$SNP,d$CHR,length))  # replcace the for loop of line 92-96 to improve efficiency\n    \n    # This section sets up positions and ticks. Ticks should be placed in the\n    # middle of a chromosome. The a new pos column is added that keeps a running\n    # sum of the positions of each successive chromsome. For example:\n    # chr bp pos\n    # 1   1  1\n    # 1   2  2\n    # 2   1  3\n    # 2   2  4\n    # 3   1  5\n    nchr = length(unique(d$CHR))\n    if (nchr==1) { ## For a single chromosome\n        ## Uncomment the next two linex to plot single chr results in Mb\n        #options(scipen=999)\n        #d$pos=d$BP/1e6\n        d$pos=d$BP\n      #  ticks=floor(length(d$pos))/2+1          ## unused, from code line: 169\n        xlabel = paste('Chromosome',unique(d$CHR),'position')\n      #  labs = ticks          ## unused, from code line: 169\n    } else { ## For multiple chromosomes\n        lastbase=0\n        ticks=NULL\n        for (i in unique(d$index)) {\n            if (i==1) {\n                d[d$index==i, ]$pos=d[d$index==i, ]$BP\n            } else {\n        ## chromosome position maybe not start at 1, eg. 9999. So gaps may be produced. \n        lastbase = lastbase +max(d[d$index==(i-1),\"BP\"])   # replace line 128\n        d[d$index == i,\"BP\"] = d[d$index == i,\"BP\"]-min(d[d$index==i,\"BP\"]) +1\n        d[d$index == i, \"pos\"] = d[d$index == i,\"BP\"] + lastbase    # replace line 129\n                # lastbase=lastbase+tail(subset(d,index==i-1)$BP, 1)\n                # d[d$index==i, ]$pos=d[d$index==i, ]$BP+lastbase\n           \n            }\n            # Old way: assumes SNPs evenly distributed\n            # ticks=c(ticks, d[d$index==i, ]$pos[floor(length(d[d$index==i, ]$pos)/2)+1])\n            # New way: doesn't make that assumption\n           # ticks = c(ticks, (min(d[d$index == i,]$pos) + max(d[d$index == i,]$pos))/2 + 1)  # see line 136, to reduce the burden of for loop \n        }\n    ticks <-tapply(d$pos,d$index,quantile,probs=0.5)   # replace line 135\n        xlabel = 'Chromosome'\n        #labs = append(unique(d$CHR),'') ## I forgot what this was here for... if seems to work, remove.\n        labs <- unique(d$CHR)\n    }\n    \n    # Initialize plot\n    xmax = ceiling(max(d$pos) * 1.03)\n    xmin = floor(max(d$pos) * -0.03)\n    \n    # The old way to initialize the plot\n    # plot(NULL, xaxt='n', bty='n', xaxs='i', yaxs='i', xlim=c(xmin,xmax), ylim=c(ymin,ymax),\n    #      xlab=xlabel, ylab=expression(-log[10](italic(p))), las=1, pch=20, ...)\n\n    \n    # The new way to initialize the plot.\n    ## See http://stackoverflow.com/q/23922130/654296\n    ## First, define your default arguments\n    def_args <- list(xaxt='n', bty='n', xaxs='i', yaxs='i', las=1, pch=20,\n                     xlim=c(xmin,xmax), ylim=c(0,ceiling(max(d$logp))),\n                     xlab=xlabel, ylab=expression(-log[10](italic(p))))\n    ## Next, get a list of ... arguments\n    #dotargs <- as.list(match.call())[-1L]\n    dotargs <- list(...)\n    ## And call the plot function passing NA, your ... arguments, and the default\n    ## arguments that were not defined in the ... arguments.\n    do.call(\"plot\", c(NA, dotargs, def_args[!names(def_args) %in% names(dotargs)]))\n    \n    # If manually specifying chromosome labels, ensure a character vector and number of labels matches number chrs.\n    if (!is.null(chrlabs)) {\n        if (is.character(chrlabs)) {\n            if (length(chrlabs)==length(labs)) {\n                labs <- chrlabs\n            } else {\n                warning(\"You're trying to specify chromosome labels but the number of labels != number of chromosomes.\")\n            }\n        } else {\n            warning(\"If you're trying to specify chromosome labels, chrlabs must be a character vector\")\n        }\n    }\n    \n    # Add an axis. \n    if (nchr==1) { #If single chromosome, ticks and labels automatic.\n        axis(1, ...)\n    } else { # if multiple chrs, use the ticks and labels you created above.\n        axis(1, at=ticks, labels=labs, ...)\n    }\n    \n    # Create a vector of alternatiting colors\n    #col=rep(col, max(d$CHR))  # replaced by line 187\n    col = rep_len(col, max(d$index))  ## mean this one?  the results are same\n\n    # Add points to the plot\n    if (nchr==1) {\n        with(d, points(pos, logp, pch=20, col=col[1], ...))\n    } else {\n        # if multiple chromosomes, need to alternate colors and increase the color index (icol) each chr.\n        icol=1\n        for (i in unique(d$index)) {\n            #with(d[d$index==unique(d$index)[i], ], points(pos, logp, col=col[icol], pch=20, ...))\n        points(d[d$index==i,\"pos\"], d[d$index==i,\"logp\"], col=col[icol], pch=20, ...)\n            icol=icol+1\n        }\n    }\n    \n    # Add suggestive and genomewide lines\n    if (suggestiveline) abline(h=suggestiveline, col=\"blue\")\n    if (genomewideline) abline(h=genomewideline, col=\"red\")\n    \n    # Highlight snps from a character vector\n    if (!is.null(highlight)) {\n        if (any(!(highlight %in% d$SNP))) warning(\"You're trying to highlight SNPs that don't exist in your results.\")\n        d.highlight=d[which(d$SNP %in% highlight), ]\n        with(d.highlight, points(pos, logp, col=\"green3\", pch=20, ...)) \n    }\n    \n    # Highlight top SNPs\n    if (!is.null(annotatePval)) {\n        # extract top SNPs at given p-val\n        if (logp) {\n            topHits = subset(d, P <= annotatePval)\n        } else\n            topHits = subset(d, P >= annotatePval)\n        par(xpd = TRUE)\n        # annotate these SNPs\n        if (annotateTop == FALSE) {\n          if (logp) {\n              with(subset(d, P <= annotatePval), \n                   textxy(pos, -log10(P), offset = 0.625, labs = topHits$SNP, cex = 1), ...)\n          } else\n              with(subset(d, P >= annotatePval), \n                   textxy(pos, P, offset = 0.625, labs = topHits$SNP, cex = 1), ...)\n        }\n        else {\n            # could try alternative, annotate top SNP of each sig chr\n            topHits <- topHits[order(topHits$P),]\n            topSNPs <- NULL\n            \n            for (i in unique(topHits$CHR)) {\n                \n                chrSNPs <- topHits[topHits$CHR == i,]\n                topSNPs <- rbind(topSNPs, chrSNPs[1,])\n                \n            }\n            if (logp ){\n                textxy(topSNPs$pos, -log10(topSNPs$P), offset = 0.625, labs = topSNPs$SNP, cex = 1, ...)\n            } else\n              textxy(topSNPs$pos, topSNPs$P, offset = 0.625, labs = topSNPs$SNP, cex = 1, ...)\n        }\n    }  \n    par(xpd = FALSE)\n}\n\n\n\n\nPlot GWAS associations\n\n\nCode\n#######\n# install.packages(\"R.utils\") # to read .gz files\n# install.packages(\"qqman\")\n# install.packages(\"calibrate\")\nlibrary(data.table)\nlibrary(qqman)\nlibrary(calibrate)\n\n# Manhattan plot\n\n# loop through all traits\nall_traits <- c(\"resid_stand\", \"ratio_stand\", \"diff_stand\", \"TBVstand\", \"ICVstand\", \"CSFstand\")\n\nfor(trait_name in all_traits){\n\n    dat = fread(list.files(pattern = paste0(trait_name, \"_N\")), data.table = F)\n\n    ## remove MAF below 0.01\n    dat = dat[dat$MAF > 0.01,]\n    ## remove INFO below 0.8\n    dat = dat[dat$INFO > 0.8,]\n\n    ## for some reason the function plots too many SNP names below indicated threshold - reomve names \n    dat[which(dat$P > 5e-8), \"ID\"] = NA\n\n    source(paste0(wd,\"manhattan_big.R\"))\n    png(filename = paste0(wd, \"/Manhattan\",trait_name,\"_clean.png\"), width = 1575, height=700, units=\"px\")\n\n        layout_matrix <- matrix(1:2, nrow = 1, ncol=2)\n        layout(layout_matrix,  widths = 2:1) #heights = 1.5:1,\n        par(mar=c(5, 4, 4, 2))\n        par(oma = c(3,3,3,3))\n\n    # determine color for each of the comp methods\n    if(trait_name == \"resid_stand\"){col = c(\"#004D40\", \"#00e7c0\");pretty_name = \"Lifetime atrophy (Residual score)\"}\n    if(trait_name == \"ratio_stand\"){col = c(\"#FFC107\", \"#FFE7a1\"); pretty_name = \"Lifetime atrophy (Ratio score)\"}\n    if(trait_name == \"diff_stand\"){col = c(\"#D81B60\", \"#F29ABA\"); pretty_name = \"Lifetime atrophy (Difference score)\"}\n\n\n    # Make MANHATTAN PLOT\n    main = paste0(\"Manhattan plot: \", pretty_name)\n    manhattan_big(dat, \n                main = main, \n                col = col, \n                chr=\"CHROM\",\n                bp=\"GENPOS\",\n                snp=\"ID\",\n                p=\"P\", \n                annotatePval=-log10(5e-12),\n                cex.axis = 1.5)\n\n    # Assess systmeatic bias using Genomic Inflation factor\n    # the genomic inflation factor is defined as the ratio of the median of the empirically observed distribution of test statistics to the expected mean, thus quantifying the extent of the bulk inflation and the excess false positive rate\n    chisq <- qchisq(1-dat$P,1)\n    lambda <- median(chisq)/qchisq(0.5,1)\n\n    # make qq plot\n    main <- paste0(\"QQ plot: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\")\n    qq(dat$P, main = main, cex = 1, cex.axis = 1.5)\n\n    dev.off()\n}\n\n\n\n\n\n\n\n\n\nMiami plots\nThis script was used to generate Supplementary Plots 20-23 and 28-32.\n\n\nCode\n# Aim is to contrast main effects with the main effects that controlled for interaction effects for each of the three lifetime atrophy phenotypes\n\n# 1. Read in main effects\n# 2. Read in attenuated main effects\n# 3. Create dummy columns to indicate which is which (will be used for split_by column)\n# 4. Merge the two GWAS\n# 5. Call function to contrast the two\n\nlibrary(data.table)\nlibrary(miamiplot)\nlibrary(ggplot2)\n\nall_traits <- c(\"resid_stand\", \"ratio_stand\", \"diff_stand\",\"TBVstand\")\n\n# set INFO filter\nINFOfilter = 0.9\n\n# keep only diallelic SNPs\ndiallelic = TRUE\n\n# MAF filter\nMAFfilter = 0.01\n\n#i = all_traits[1]\n\nfor(i in all_traits){\n\n    # 1. Read in main effects\n    main = fread(list.files(pattern = paste0(i, \"_N\")), data.table = F)\n\n    # dummy var\n    main$split = 1\n\n    # 2. Read in attenuated main effects\n    #att = fread(list.files(pattern = paste0(i, \"_attenuatedMainEffects\")), data.table = F)\n    att = fread(list.files(pattern = paste0(i, \"_SNPxage\")), data.table = F)\n    # dummy var\n    att$split = -1\n\n    # some associations have a P value of 0 which will give an infinite value when transforming it into log\n    # this is the case for 18,794 SNPs in resid GWAS for example, will exclude them here as plot otherwise does not work\n    #att <- att[att$P != 0,]\n\n    # 4. Merge the two GWAS\n    merged = rbind(main, att)\n\n    # if there is an info filter, filter for more reliable SNPs\n    if(any(ls() == \"INFOfilter\")){merged <- merged[merged$INFO > INFOfilter,]}\n\n    # if there is an MAF filter, filter for MAF\n    if(any(ls() == \"MAFfilter\")){merged <- merged[merged$MAF > MAFfilter,]}\n\n    # if diallelic has been set to TRUE, filter for diallelic SNPs only\n    if(any(ls() == \"diallelic\")){   \n        if(diallelic == T){\n            merged <- merged[which(nchar(merged$ALLELE0) == 1),]\n            merged <- merged[which(nchar(merged$ALLELE1) == 1),]\n    }}\n\n    #merged = merged[merged$CHROM == 1,] # for testing\n\n    # summary(merged$P[which(merged$split == -1)])\n    # summary(merged$P[which(merged$split == 1)])\n\n    # clean up big files\n    rm(list = c(\"att\", \"main\"))\n\n    # plot\n    if(grepl(\"diff\", i)){prettyName = \"Difference score\"; col = c(\"#D81B60\", \"#F29ABA\")}\n    if(grepl(\"ratio\", i)){prettyName = \"Ratio score\"; col = c(\"#FFC107\", \"#FFE7a1\")}\n    if(grepl(\"resid\", i)){prettyName = \"Residual score\"; col = c(\"#004D40\", \"#00e7c0\")}\n    if(grepl(\"TBV\", i)){prettyName = \"TBV\"; col = c(\"#82A0D8\",\"#8DDFCB\")}\n\n    ulabel = paste0(\"Main SNP effects\\n(Original GWAS)\")\n    #llabel = paste0( \"Main SNP effects\\n(GWAS including SNP-by-age interaction term)\")\n    llabel = paste0( \"SNP-by-age effects (Interaction GWAS)\")\n\n    p = ggmiami(data = merged, \n            chr = \"CHROM\",\n            pos = \"GENPOS\",\n            p = \"P\",\n            split_by = \"split\", split_at = 0,\n            upper_ylab = ulabel,\n            lower_ylab = llabel,\n            chr_colors = col)\n\n    # save plot\n    fileName = paste0(wd,\"/miami_SNPxage_\",i)\n\n    # if INFO filter was used, write into file name\n    if(any(ls() == \"INFOfilter\")){fileName = paste0(fileName,\"_INFO\", INFOfilter)}\n\n    # if INFO filter was used, write into file name\n    if(any(ls() == \"MAFfilter\")){fileName = paste0(fileName,\"_MAF\", MAFfilter)}\n\n    # if only diallelic SNPs used, say in the name\n    if(any(ls() == \"diallelic\")){\n        if(diallelic == T){\n            fileName = paste0(fileName, \"_diallelic\")\n    }}\n\n    fileName = paste0(fileName, \"_2.png\")\n\n    ggsave(fileName, plot = p, width = 20, height = 10, dpi = 200)\n}\n\n\n\n\n\n\n\n\n\nExamine QQ plots\nThis was used to generate Supplementary Plot 33.\n\n\nCode\n### examine why the qqplot seems so inflated\n# plot qq all, MAF filter & INFO filter, hm3 SNPs (MAF > 0.01; INFO > 0.9), 1000G SNPs (MAF > 0.01; INFO > 0.9)\n\nlibrary(data.table)\nlibrary(qqman)\nlibrary(calibrate)\nlibrary(cowplot)\nlibrary(ggplot2)\n\n# loop through all three traits\nall_traits <- c(\"resid_stand\", \"ratio_stand\", \"diff_stand\")\n\nfor(trait_name in all_traits){\n    dat = fread(list.files(pattern = paste0(trait_name, \"_N\")), data.table = F)#, nrows = 200000\n    #dat = dat[1:20000,]\n    #dat = dat[dat$CHROM == 22,]\n\n    # determine color for each of the comp methods\n    if(trait_name == \"resid_stand\"){pretty_name = \"Residual score\"}\n    if(trait_name == \"ratio_stand\"){pretty_name = \"Ratio score\"}\n    if(trait_name == \"diff_stand\"){pretty_name = \"Difference score\"}\n\n    # set up to save plot\n    fileName <- paste0(\"/CCACE_Shared/Anna_F/BrainAtrophy/data/QQeval_\",trait_name,\".png\")\n    png(filename = fileName, width = 1000, height=1000, units=\"px\")\n\n        layout_matrix <- matrix(c(1,3,5,2,4,6), ncol=2, nrow=3)\n        layout(layout_matrix,  widths = 1:1:1:1:1:1) #heights = 1.5:1,\n        par(mar=c(5, 4, 4, 2))\n        par(oma = c(3,3,3,3))\n\n\n    ## PLOT 1: all SNPs\n    ### Calculate Genomic Inflation factor\n    chisq <- qchisq(1-dat$P,1)\n    lambda <- median(chisq)/qchisq(0.5,1)\n\n    # make qq plot\n    main <- paste0(\"All SNPs: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat), \" SNPs\")\n    p1 <- qq(dat$P, main = main, cex = 1, cex.axis = 1.5)\n\n    ###############################\n    ## PLOT 2: Apply INFO and MAF filter\n    dat2 = dat[dat$MAF > 0.01,]\n    dat2 = dat2[dat2$INFO > 0.8,]\n\n    ### Calculate Genomic Inflation factor\n    chisq <- qchisq(1-dat2$P,1)\n    lambda <- median(chisq)/qchisq(0.5,1)\n\n    # make qq plot\n    main <- paste0(\"SNPs passing INFO > 0.9 & MAF > 0.01 filters:\\n\", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat2), \" SNPs\")\n    p2 <- qq(dat2$P, main = main, cex = 1, cex.axis = 1.5)\n\n    ###############################\n    ## PLOT 3: HapMap3 SNPs only\n    hm3 <- \"eur_w_ld_chr/w_hm3.snplist\"\n    hm3SNPs <- fread(hm3)\n    names(hm3SNPs) <- c(\"ID\", \"ALLELE1\", \"ALLELE0\")\n\n    # merge the two data sets and only keep overlapping SNPS that agree in A1 and A2\n    dat2 <- merge(dat, hm3SNPs, by = \"ID\")\n\n    ### Calculate Genomic Inflation factor\n    chisq <- qchisq(1-dat2$P,1)\n    lambda <- median(chisq)/qchisq(0.5,1)\n\n    # make qq plot\n    main <- paste0(\"HapMap3 SNPs: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat2), \" SNPs\")\n    p3 <- qq(dat2$P, main = main, cex = 1, cex.axis = 1.5)\n    \n    ###############################\n    ## PLOT 4: 1000 Genomes SNPs only\n    # different reference files: this one is from FUMA website\n    ref = \"1KGphase3EURvariants.txt.gz\"\n    ref1000 <- fread(ref, select = c(\"SNP\", \"A1\", \"A2\"))\n    names(ref1000) <- c(\"ID\", \"ALLELE1\", \"ALLELE0\")\n\n    # merge the two data sets and only keep overlapping SNPS that agree in A1 and A2\n    dat2 <- merge(dat, ref1000, by = \"ID\")\n\n    ### Calculate Genomic Inflation factor\n    chisq <- qchisq(1-dat2$P,1)\n    lambda <- median(chisq)/qchisq(0.5,1)\n\n    # make qq plot\n    main <- paste0(\"1000 Genomes SNPs: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat2), \" SNPs\")\n    p4 <- qq(dat2$P, main = main, cex = 1, cex.axis = 1.5)\n    \n    ###############################\n    ## PLOT 5: HapMap3 SNPs removed\n    # isolate SNPs not shared between data and hm3\n    notHm3 = setdiff(dat$ID, hm3SNPs$ID)\n\n    # only retain those \n    dat2 <- dat[dat$ID %in% notHm3,]\n    \n    ### Calculate Genomic Inflation factor\n    chisq <- qchisq(1-dat2$P,1)\n    lambda <- median(chisq)/qchisq(0.5,1)\n\n    # make qq plot\n    main <- paste0(\"All SNPs that are not HapMap3: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat2), \" SNPs\")\n    p5 <- qq(dat2$P, main = main, cex = 1, cex.axis = 1.5)\n\n    # save\n    dev.off()\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lifetime brain atrophy GWAS",
    "section": "",
    "text": "Here I display the analysis code to accompany our lifetime brain atrophy (LBA) genetics project. For consistency, the analysis steps outlined below match the order of presentation in the manuscript but does not necessarily reflect the order in which analyses were executed.\nPre-registration: https://osf.io/gydmw/\n\nAnalysis steps\nData preparation\n\nUK Biobank\n1.1. Phenotypic data\n1.2. Neuroimaging data\n1.3. Genetic data\nLBC1936\n2.1. Phenotypic data\n2.2. Neuroimaging data\nHuman Connectome Project (HCP)\nGeneration Scotland Subsample (STRADL)\nMRi-Share\n\nDescription and characterisation of the LBA phenotype\n\nMeasures of LBA predict brain atrophy rated by neuroradiological experts, as well as other ageing-related health traits such as frailty and cognitive ability\nMeasures of LBA indicate age-associated brain shrinkage\n2.1. Single time-point MRI measures age correlation\n2.2. Repeated MRI measures age correlations in LBC1936\nLBA moderately captures within-person atrophic changes that were longitudinally observed between two MRI scans a few years apart\n\nGenome-wide association study of LBA\n\nSNP-heritability\nGWAS analysis\nGenetic correlations\n\n\n\n\n\nGWAS Manhattan plot for LBA (residual score)"
  }
]