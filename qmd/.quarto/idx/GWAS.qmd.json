{"title":"Genome-wide association study","markdown":{"yaml":{"title":"Genome-wide association study","format":{"html":{"code-fold":true}},"author":"Anna Elisabeth Furtjes","date":"`r format(Sys.time(), '%d %B %Y')`","output":"html","doi":"test"},"headingText":"quarto::quarto_render(input = \"GWAS.qmd\", output_file = \"GWAS.html\")","containsRefs":false,"markdown":"\n\n------------------------------------------------------------------------\n\n```{r setup, include=F, warning=F, message=F, eval=F}\nload(\"paths.RData\")\n```\n\nGWAS analysis was performed with the [REGENIE software](https://rgcgithub.github.io/regenie/).\n\nInput data was prepared using scripts for [phenotypic](UKB_neuro.html) and [genotype data](UKB_geneticQC.html). Imputed data was imputed using the Michigan imputation server. \n\nEnsure that the `resid_stand` variable was calculated in the subsample with non-missing data that is analysed in the GWAS analysis.\n\n## Regenie: Step 1\n\n```{bash, eval=F}\n#!/bin/bash\n\nregenie_v3.4 \\\n--step 1 \\\n--bed $genotype/ukb_neuroimaging_brainAtrophy_GWASinput \\\n--phenoFile $phenotype/UKB_CrossNeuroIDP_noOutliers.txt \\\n--phenoColList ${trait}  \\\n--covarFile $phenotype/UKB_covarGWAS.txt \\\n--catCovarList sex,assessmentMonth,site,array,batch \\\n--bsize 100 \\\n--threads 30 \\\n--maxCatLevels 106 \\\n--lowmem \\\n--lowmem-prefix ${wd}/tmp_noOutliers \\\n--iid-only \\\n--out ${wd}/Step1_out_all_noOutliers\n```\n\n## Regenie: Step 2\n\n```{bash, eval=F}\n#!/bin/bash\n\nregenie_v3.4 \\\n--step 2 \\\n--bgen $imputed/ukb_chr${CHR}_clean_v3.bgen \\\n--sample $sampleFile/ukb10279_imp_chr${CHR}_v3_s487395.sample \\\n--keep $genotype/ukb_neuroimaging_brainAtrophy_GWASinput.fam \\\n--covarFile $phenotype/UKB_covarGWAS.txt \\\n--catCovarList sex,assessmentMonth,site,array,batch \\\n--maxCatLevels 106 \\\n--phenoFile $phenotype/UKB_CrossNeuroIDP_noOutliers.txt \\\n--phenoColList ${trait} \\\n--bsize 400 \\\n--minINFO 0.4 \\\n--minMAC 5 \\\n--threads 5 \\\n--pred ${step1}/Step1_out_all_pred_noOutliers.list \\\n--out $wd/GWAS_${trait}_chr${CHR}\n```\n\n## Regenie interaction models: step 2\n\nAs unintuitive as it may seem, you must standardise the age variable before running this script. Regenie calculates a product-wise variable for the interaction between phenotype and age and if age is indicated in months or even days, the variable will be so large that regenie cannot handle it, and results will be massively inflated (results are complete nonsense with every SNP being extremely significant).\n\n```{bash, eval=F}\n#!/bin/bash\n\n# note that this script only runs when linked to the bgen sample file \n\ntrait=$1\n\nfor CHR in {1..22}\ndo\nregenie_v3.4 \\\n--step 2 \\\n--bgen $imputed/ukb_chr${CHR}_clean_v3.bgen \\\n--ref-first \\\n--sample $sampleFile/ukb10279_imp_chr${CHR}_v3_s487395.sample \\\n--keep $genotype/ukb_neuroimaging_brainAtrophy_GWASinput.fam \\\n--covarFile $phenotype/UKB_covarGWAS.txt \\\n--catCovarList sex,assessmentMonth,site,array,batch \\\n--maxCatLevels 106 \\\n--phenoFile $phenotype/UKB_CrossNeuroIDP_noOutliers.txt \\\n--phenoColList ${trait} \\\n--bsize 400 \\\n--minINFO 0.4 \\\n--minMAC 5 \\\n--threads 5 \\\n--gz \\\n--interaction age \\\n--pred ${step1}/Step1_out_all_noOutliers_pred.list \\\n--out $wd/GWAS_${trait}_chr${CHR}_interaction\ndone\n\n```\n\n## Format GWAS data\n\n```{r, eval=F}\nlibrary(data.table)\nlibrary(stringr)\n\n# Read in the files for each area and merge them \nall_traits<-c(\"resid_stand\",\"ratio_stand\",\"diff_stand\",\"TBVstand\",\"ICVstand\",\"CSFstand\")\n\nfor(i in all_traits){\n\n\t# list all files that belong to this trait\n\tfileNames = list.files(pattern = i)\t\n\tfileNames = fileNames[grepl(\".regenie.gz\", fileNames)]\n\t\n\n\t# exclude the 'interaction' GWAS\n\tfileNames = fileNames[!grepl(\"_interaction_\", fileNames)]\n\t# include the 'interaction' GWAS\n\t#fileNames = fileNames[grepl(\"_interaction_\", fileNames)]\n\n\t# sex split analyses\n\t#fileNames<-fileNames[grepl(\"_males\", fileNames)]\n\t#i = paste0(i,\"_males\")\n\n\t# count number of chromosomes\n\tif(length(fileNames) != 22){warning(paste0(i, \" GWAS has not got exactly 22 chromosome files!\"))}\n\n    # set object to count number of rows to 0\n    count_rows<-0\n\t\n\t# object to hold GWAS\n\tdat <- data.frame()    \n\n     for(j in fileNames){\n            \n       print(j)\n\n\t\t# read in file\n       file<-fread(j,header=T,data.table=F)\n\n\t\t# if this is an interaction test, only keep interaction row for each SNP\n\t\tif(grepl(\"interaction\", j)){\n\t\t\t\n\t\t\t# pull out the interaction effect from the full model\n\t\t\tfile <- file[grepl(\"SNPxage\", file$TEST),] \n\n\t\t\t# if we're interested to look at attenuation of SNP effects, we can pull out ADD_INT_SNP which should represent the main effect of the tested SNP in the interaction model\n\t\t\t#file <- file[grepl(\"INT_SNP\", file$TEST),] \n\t\t\t# remove SNPxage\n\t\t\t#file <- file[!grepl(\"SNPxage\", file$TEST),]\n\t\t}\n\n\t\t# merge\n\t\tdat <- rbind(dat, file) \n       \n\t\t# count number of rows \n        count_rows<-count_rows+nrow(file)\n     }\n    \n    print(\"Done merging chromosome files\")\n    \n    ## Sanity checks: Does the resulting file have the expected dimensions?\n    if(nrow(dat)!= count_rows){print(\"Resulting merged file does not match the expected numeber of rows\");break}\n    \n    if(ncol(dat) != 14){print(\"Resulting merged files does not match the expected number of columns\"); break}\n    \n    print(\"File has dimensions as expected\")\n    print(dim(dat))\n    \n    # transform pvalues from log transformation to regular\n    # https://www.biostars.org/p/358046/\n    dat$P<-10^(-dat$LOG10P)\n    #if(min(dat$P,na.rm=T)<=0 | max(dat$P,na.rm=T) >= 1){\"Transformed p-value is out of bounds\"; break}\n    summary(dat$P)\n\n    print(\"Done transform p-value column, and p-values are between 0 and 1\")\n\n    # create MAF column\n    dat$MAF<-ifelse(dat$A1FREQ < 0.5, dat$A1FREQ, 1-dat$A1FREQ)\n\n\t# remove EXTRA column because it's empty\n\tdat$EXTRA <- NULL\n\n    print(paste0(\"This is the file head for \",i))\n    print(head(dat))\n    \n    # define file name to save the merged file\n    fileName <- paste0(\"/CCACE_Shared/Anna_F/BrainAtrophy/data/regenie_out/finalGWAS/GWAS_brainAtrophy_\", i,\"_N43110.gz\")\n\t\n\t# if this is an interaction run, name accordingly}               \n\tif(grepl(\"interaction\", j)){\n\t\t#fileName <- paste0(wd,\"/GWAS_brainAtrophy_\", i,\"_attenuatedMainEffects_N43110.gz\")\n\t\tfileName <- paste0(wd,\"/GWAS_brainAtrophy_\", i,\"_SNPxage_N43110.gz\")\n\t}\n\n    # save merged file\n    fwrite(dat, fileName, na = \"NA\", quote = F, sep = \"\\t\", row.names = FALSE, col.names = TRUE)\n    \n    print(paste0(\"Done writing file for \", i))\n}\n\nprint(\"Done all traits\")\n```\n\n## Manhattan plot\n\nThe scripts below were used to make Figure 4 in the main paper, and Supplementary Plots 15-19.\n\n### Alter Manhattan function for better looking annotation\n\nThis function was saved in a file called `manhattan_big.R` to be read in with `source(manhattan_big.R)` in the next step.\n\n```{r Manhattan_big, eval=F}\nmanhattan_big <- function(x, chr=\"CHR\", bp=\"BP\", p=\"P\", snp=\"SNP\", \n                      col=c(\"gray10\", \"gray60\"), chrlabs=NULL,\n                      suggestiveline=-log10(1e-5), genomewideline=-log10(5e-8), \n                      highlight=NULL, logp=TRUE, annotatePval = NULL, annotateTop = TRUE, ...) {\n\n    # Not sure why, but package check will warn without this.\n    CHR=BP=P=index=NULL\n    \n    # Check for sensible dataset\n    ## Make sure you have chr, bp and p columns.\n    if (!(chr %in% names(x))) stop(paste(\"Column\", chr, \"not found!\"))\n    if (!(bp %in% names(x))) stop(paste(\"Column\", bp, \"not found!\"))\n    if (!(p %in% names(x))) stop(paste(\"Column\", p, \"not found!\"))\n    ## warn if you don't have a snp column\n    if (!(snp %in% names(x))) warning(paste(\"No SNP column found. OK unless you're trying to highlight.\"))\n    ## make sure chr, bp, and p columns are numeric.\n    if (!is.numeric(x[[chr]])) stop(paste(chr, \"column should be numeric. Do you have 'X', 'Y', 'MT', etc? If so change to numbers and try again.\"))\n    if (!is.numeric(x[[bp]])) stop(paste(bp, \"column should be numeric.\"))\n    if (!is.numeric(x[[p]])) stop(paste(p, \"column should be numeric.\"))\n    \n    # Create a new data.frame with columns called CHR, BP, and P.\n    # d=data.frame(CHR=x[[chr]], BP=x[[bp]], P=x[[p]], pos = NA, index = NA) # with millions of SNPs, create dataframe at once \n\t                                                         #  rather than dynamically allocated(see line 72-73, and remove line 87 and line 91 )\n    \n    # If the input data frame has a SNP column, add it to the new data frame you're creating.\n    if (!is.null(x[[snp]])) d = data.frame(CHR=x[[chr]], BP=x[[bp]], P=x[[p]], pos = NA, index = NA ,SNP=x[[snp]], stringsAsFactors = FALSE) else \n\t    d = data.frame(CHR=x[[chr]], BP=x[[bp]], P=x[[p]], pos = NA, index = NA)\n\t    \n    \n    # Set positions, ticks, and labels for plotting\n    ## Sort and keep only values where is numeric.\n    #d <- subset(d[order(d$CHR, d$BP), ], (P>0 & P<=1 & is.numeric(P)))\n    #  d <- subset(d, (is.numeric(CHR) & is.numeric(BP) & is.numeric(P)))       ## unused, all three variables are numeric, line:63-65 \n    d <- d[order(d$CHR, d$BP), ]\n    #d$logp <- ifelse(logp, yes=-log10(d$P), no=d$P)\n    if (logp) {\n        d$logp <- -log10(d$P)\n    } else {\n        d$logp <- d$P\n    }\n   # d$pos=NA\n    \n    \n    # Fixes the bug where one chromosome is missing by adding a sequential index column.\n   # d$index=NA\n   # ind = 0\n   # for (i in unique(d$CHR)){\n   #     ind = ind + 1\n   #     d[d$CHR==i,]$index = ind\n   # }\n   d$index = rep.int(seq_along(unique(d$CHR)), times = tapply(d$SNP,d$CHR,length))  # replcace the for loop of line 92-96 to improve efficiency\n    \n    # This section sets up positions and ticks. Ticks should be placed in the\n    # middle of a chromosome. The a new pos column is added that keeps a running\n    # sum of the positions of each successive chromsome. For example:\n    # chr bp pos\n    # 1   1  1\n    # 1   2  2\n    # 2   1  3\n    # 2   2  4\n    # 3   1  5\n    nchr = length(unique(d$CHR))\n    if (nchr==1) { ## For a single chromosome\n        ## Uncomment the next two linex to plot single chr results in Mb\n        #options(scipen=999)\n\t    #d$pos=d$BP/1e6\n        d$pos=d$BP\n      #  ticks=floor(length(d$pos))/2+1          ## unused, from code line: 169\n        xlabel = paste('Chromosome',unique(d$CHR),'position')\n      #  labs = ticks          ## unused, from code line: 169\n    } else { ## For multiple chromosomes\n        lastbase=0\n        ticks=NULL\n        for (i in unique(d$index)) {\n            if (i==1) {\n                d[d$index==i, ]$pos=d[d$index==i, ]$BP\n            } else {\n\t\t## chromosome position maybe not start at 1, eg. 9999. So gaps may be produced. \n\t\tlastbase = lastbase +max(d[d$index==(i-1),\"BP\"])   # replace line 128\n\t\td[d$index == i,\"BP\"] = d[d$index == i,\"BP\"]-min(d[d$index==i,\"BP\"]) +1\n\t\td[d$index == i, \"pos\"] = d[d$index == i,\"BP\"] + lastbase    # replace line 129\n                # lastbase=lastbase+tail(subset(d,index==i-1)$BP, 1)\n                # d[d$index==i, ]$pos=d[d$index==i, ]$BP+lastbase\n\t\t   \n            }\n            # Old way: assumes SNPs evenly distributed\n            # ticks=c(ticks, d[d$index==i, ]$pos[floor(length(d[d$index==i, ]$pos)/2)+1])\n            # New way: doesn't make that assumption\n           # ticks = c(ticks, (min(d[d$index == i,]$pos) + max(d[d$index == i,]$pos))/2 + 1)  # see line 136, to reduce the burden of for loop \n        }\n\tticks <-tapply(d$pos,d$index,quantile,probs=0.5)   # replace line 135\n        xlabel = 'Chromosome'\n        #labs = append(unique(d$CHR),'') ## I forgot what this was here for... if seems to work, remove.\n        labs <- unique(d$CHR)\n    }\n    \n    # Initialize plot\n    xmax = ceiling(max(d$pos) * 1.03)\n    xmin = floor(max(d$pos) * -0.03)\n    \n    # The old way to initialize the plot\n    # plot(NULL, xaxt='n', bty='n', xaxs='i', yaxs='i', xlim=c(xmin,xmax), ylim=c(ymin,ymax),\n    #      xlab=xlabel, ylab=expression(-log[10](italic(p))), las=1, pch=20, ...)\n\n    \n    # The new way to initialize the plot.\n    ## See http://stackoverflow.com/q/23922130/654296\n    ## First, define your default arguments\n    def_args <- list(xaxt='n', bty='n', xaxs='i', yaxs='i', las=1, pch=20,\n                     xlim=c(xmin,xmax), ylim=c(0,ceiling(max(d$logp))),\n                     xlab=xlabel, ylab=expression(-log[10](italic(p))))\n    ## Next, get a list of ... arguments\n    #dotargs <- as.list(match.call())[-1L]\n    dotargs <- list(...)\n    ## And call the plot function passing NA, your ... arguments, and the default\n    ## arguments that were not defined in the ... arguments.\n    do.call(\"plot\", c(NA, dotargs, def_args[!names(def_args) %in% names(dotargs)]))\n    \n    # If manually specifying chromosome labels, ensure a character vector and number of labels matches number chrs.\n    if (!is.null(chrlabs)) {\n        if (is.character(chrlabs)) {\n            if (length(chrlabs)==length(labs)) {\n                labs <- chrlabs\n            } else {\n                warning(\"You're trying to specify chromosome labels but the number of labels != number of chromosomes.\")\n            }\n        } else {\n            warning(\"If you're trying to specify chromosome labels, chrlabs must be a character vector\")\n        }\n    }\n    \n    # Add an axis. \n    if (nchr==1) { #If single chromosome, ticks and labels automatic.\n        axis(1, ...)\n    } else { # if multiple chrs, use the ticks and labels you created above.\n        axis(1, at=ticks, labels=labs, ...)\n    }\n    \n    # Create a vector of alternatiting colors\n    #col=rep(col, max(d$CHR))  # replaced by line 187\n    col = rep_len(col, max(d$index))  ## mean this one?  the results are same\n\n    # Add points to the plot\n    if (nchr==1) {\n        with(d, points(pos, logp, pch=20, col=col[1], ...))\n    } else {\n        # if multiple chromosomes, need to alternate colors and increase the color index (icol) each chr.\n        icol=1\n        for (i in unique(d$index)) {\n            #with(d[d$index==unique(d$index)[i], ], points(pos, logp, col=col[icol], pch=20, ...))\n\t    points(d[d$index==i,\"pos\"], d[d$index==i,\"logp\"], col=col[icol], pch=20, ...)\n            icol=icol+1\n        }\n    }\n    \n    # Add suggestive and genomewide lines\n    if (suggestiveline) abline(h=suggestiveline, col=\"blue\")\n    if (genomewideline) abline(h=genomewideline, col=\"red\")\n    \n    # Highlight snps from a character vector\n    if (!is.null(highlight)) {\n        if (any(!(highlight %in% d$SNP))) warning(\"You're trying to highlight SNPs that don't exist in your results.\")\n        d.highlight=d[which(d$SNP %in% highlight), ]\n        with(d.highlight, points(pos, logp, col=\"green3\", pch=20, ...)) \n    }\n    \n    # Highlight top SNPs\n    if (!is.null(annotatePval)) {\n        # extract top SNPs at given p-val\n        if (logp) {\n            topHits = subset(d, P <= annotatePval)\n        } else\n            topHits = subset(d, P >= annotatePval)\n        par(xpd = TRUE)\n        # annotate these SNPs\n        if (annotateTop == FALSE) {\n          if (logp) {\n              with(subset(d, P <= annotatePval), \n                   textxy(pos, -log10(P), offset = 0.625, labs = topHits$SNP, cex = 1), ...)\n          } else\n              with(subset(d, P >= annotatePval), \n                   textxy(pos, P, offset = 0.625, labs = topHits$SNP, cex = 1), ...)\n        }\n        else {\n            # could try alternative, annotate top SNP of each sig chr\n            topHits <- topHits[order(topHits$P),]\n            topSNPs <- NULL\n            \n            for (i in unique(topHits$CHR)) {\n                \n                chrSNPs <- topHits[topHits$CHR == i,]\n                topSNPs <- rbind(topSNPs, chrSNPs[1,])\n                \n            }\n            if (logp ){\n                textxy(topSNPs$pos, -log10(topSNPs$P), offset = 0.625, labs = topSNPs$SNP, cex = 1, ...)\n            } else\n              textxy(topSNPs$pos, topSNPs$P, offset = 0.625, labs = topSNPs$SNP, cex = 1, ...)\n        }\n    }  \n    par(xpd = FALSE)\n}\n```\n\n### Plot GWAS associations\n\n```{r, eval=F}\n#######\n# install.packages(\"R.utils\") # to read .gz files\n# install.packages(\"qqman\")\n# install.packages(\"calibrate\")\nlibrary(data.table)\nlibrary(qqman)\nlibrary(calibrate)\n\n# Manhattan plot\n\n# loop through all traits\nall_traits <- c(\"resid_stand\", \"ratio_stand\", \"diff_stand\", \"TBVstand\", \"ICVstand\", \"CSFstand\")\n\nfor(trait_name in all_traits){\n\n\tdat = fread(list.files(pattern = paste0(trait_name, \"_N\")), data.table = F)\n\n\t## remove MAF below 0.01\n\tdat = dat[dat$MAF > 0.01,]\n\t## remove INFO below 0.8\n\tdat = dat[dat$INFO > 0.8,]\n\n\t## for some reason the function plots too many SNP names below indicated threshold - reomve names \n\tdat[which(dat$P > 5e-8), \"ID\"] = NA\n\n\tsource(paste0(wd,\"manhattan_big.R\"))\n\tpng(filename = paste0(wd, \"/Manhattan\",trait_name,\"_clean.png\"), width = 1575, height=700, units=\"px\")\n\n\t\tlayout_matrix <- matrix(1:2, nrow = 1, ncol=2)\n\t\tlayout(layout_matrix,  widths = 2:1) #heights = 1.5:1,\n\t\tpar(mar=c(5, 4, 4, 2))\n\t\tpar(oma = c(3,3,3,3))\n\n\t# determine color for each of the comp methods\n\tif(trait_name == \"resid_stand\"){col = c(\"#004D40\", \"#00e7c0\");pretty_name = \"Lifetime atrophy (Residual score)\"}\n\tif(trait_name == \"ratio_stand\"){col = c(\"#FFC107\", \"#FFE7a1\"); pretty_name = \"Lifetime atrophy (Ratio score)\"}\n\tif(trait_name == \"diff_stand\"){col = c(\"#D81B60\", \"#F29ABA\"); pretty_name = \"Lifetime atrophy (Difference score)\"}\n\n\n\t# Make MANHATTAN PLOT\n\tmain = paste0(\"Manhattan plot: \", pretty_name)\n\tmanhattan_big(dat, \n\t\t\t\tmain = main, \n\t\t\t\tcol = col, \n\t\t\t\tchr=\"CHROM\",\n\t\t\t\tbp=\"GENPOS\",\n\t\t\t\tsnp=\"ID\",\n\t\t\t\tp=\"P\", \n\t\t\t\tannotatePval=-log10(5e-12),\n\t\t\t\tcex.axis = 1.5)\n\n\t# Assess systmeatic bias using Genomic Inflation factor\n\t# the genomic inflation factor is defined as the ratio of the median of the empirically observed distribution of test statistics to the expected mean, thus quantifying the extent of the bulk inflation and the excess false positive rate\n\tchisq <- qchisq(1-dat$P,1)\n\tlambda <- median(chisq)/qchisq(0.5,1)\n\n\t# make qq plot\n\tmain <- paste0(\"QQ plot: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\")\n\tqq(dat$P, main = main, cex = 1, cex.axis = 1.5)\n\n\tdev.off()\n}\n```\n\n![](images/Manhattanratio_stand.png){fig-align=\"center\"}\n\n### Miami plots\n\nThis script was used to generate Supplementary Plots 20-23 and 28-32.\n\n```{r miami, eval=F}\n# Aim is to contrast main effects with the main effects that controlled for interaction effects for each of the three lifetime atrophy phenotypes\n\n# 1. Read in main effects\n# 2. Read in attenuated main effects\n# 3. Create dummy columns to indicate which is which (will be used for split_by column)\n# 4. Merge the two GWAS\n# 5. Call function to contrast the two\n\nlibrary(data.table)\nlibrary(miamiplot)\nlibrary(ggplot2)\n\nall_traits <- c(\"resid_stand\", \"ratio_stand\", \"diff_stand\",\"TBVstand\")\n\n# set INFO filter\nINFOfilter = 0.9\n\n# keep only diallelic SNPs\ndiallelic = TRUE\n\n# MAF filter\nMAFfilter = 0.01\n\n#i = all_traits[1]\n\nfor(i in all_traits){\n\n\t# 1. Read in main effects\n\tmain = fread(list.files(pattern = paste0(i, \"_N\")), data.table = F)\n\n\t# dummy var\n\tmain$split = 1\n\n\t# 2. Read in attenuated main effects\n\t#att = fread(list.files(pattern = paste0(i, \"_attenuatedMainEffects\")), data.table = F)\n\tatt = fread(list.files(pattern = paste0(i, \"_SNPxage\")), data.table = F)\n\t# dummy var\n\tatt$split = -1\n\n\t# some associations have a P value of 0 which will give an infinite value when transforming it into log\n\t# this is the case for 18,794 SNPs in resid GWAS for example, will exclude them here as plot otherwise does not work\n\t#att <- att[att$P != 0,]\n\n\t# 4. Merge the two GWAS\n\tmerged = rbind(main, att)\n\n\t# if there is an info filter, filter for more reliable SNPs\n\tif(any(ls() == \"INFOfilter\")){merged <- merged[merged$INFO > INFOfilter,]}\n\n\t# if there is an MAF filter, filter for MAF\n\tif(any(ls() == \"MAFfilter\")){merged <- merged[merged$MAF > MAFfilter,]}\n\n\t# if diallelic has been set to TRUE, filter for diallelic SNPs only\n\tif(any(ls() == \"diallelic\")){\t\n\t\tif(diallelic == T){\n\t\t\tmerged <- merged[which(nchar(merged$ALLELE0) == 1),]\n\t\t\tmerged <- merged[which(nchar(merged$ALLELE1) == 1),]\n\t}}\n\n\t#merged = merged[merged$CHROM == 1,] # for testing\n\n\t# summary(merged$P[which(merged$split == -1)])\n\t# summary(merged$P[which(merged$split == 1)])\n\n\t# clean up big files\n\trm(list = c(\"att\", \"main\"))\n\n\t# plot\n\tif(grepl(\"diff\", i)){prettyName = \"Difference score\"; col = c(\"#D81B60\", \"#F29ABA\")}\n\tif(grepl(\"ratio\", i)){prettyName = \"Ratio score\"; col = c(\"#FFC107\", \"#FFE7a1\")}\n\tif(grepl(\"resid\", i)){prettyName = \"Residual score\"; col = c(\"#004D40\", \"#00e7c0\")}\n\tif(grepl(\"TBV\", i)){prettyName = \"TBV\"; col = c(\"#82A0D8\",\"#8DDFCB\")}\n\n\tulabel = paste0(\"Main SNP effects\\n(Original GWAS)\")\n\t#llabel = paste0( \"Main SNP effects\\n(GWAS including SNP-by-age interaction term)\")\n\tllabel = paste0( \"SNP-by-age effects (Interaction GWAS)\")\n\n\tp = ggmiami(data = merged, \n\t\t\tchr = \"CHROM\",\n\t\t\tpos = \"GENPOS\",\n\t\t\tp = \"P\",\n\t\t    split_by = \"split\", split_at = 0,\n\t\t    upper_ylab = ulabel,\n\t\t    lower_ylab = llabel,\n\t\t\tchr_colors = col)\n\n\t# save plot\n\tfileName = paste0(wd,\"/miami_SNPxage_\",i)\n\n\t# if INFO filter was used, write into file name\n\tif(any(ls() == \"INFOfilter\")){fileName = paste0(fileName,\"_INFO\", INFOfilter)}\n\n\t# if INFO filter was used, write into file name\n\tif(any(ls() == \"MAFfilter\")){fileName = paste0(fileName,\"_MAF\", MAFfilter)}\n\n\t# if only diallelic SNPs used, say in the name\n\tif(any(ls() == \"diallelic\")){\n\t\tif(diallelic == T){\n\t\t\tfileName = paste0(fileName, \"_diallelic\")\n\t}}\n\n\tfileName = paste0(fileName, \"_2.png\")\n\n\tggsave(fileName, plot = p, width = 20, height = 10, dpi = 200)\n}\n```\n\n![](images/miami_resid_stand_2.png){fig-align=\"center\"}\n\n### Examine QQ plots\n\nThis was used to generate Supplementary Plot 33.\n\n```{r, eval = F}\n### examine why the qqplot seems so inflated\n# plot qq all, MAF filter & INFO filter, hm3 SNPs (MAF > 0.01; INFO > 0.9), 1000G SNPs (MAF > 0.01; INFO > 0.9)\n\nlibrary(data.table)\nlibrary(qqman)\nlibrary(calibrate)\nlibrary(cowplot)\nlibrary(ggplot2)\n\n# loop through all three traits\nall_traits <- c(\"resid_stand\", \"ratio_stand\", \"diff_stand\")\n\nfor(trait_name in all_traits){\n\tdat = fread(list.files(pattern = paste0(trait_name, \"_N\")), data.table = F)#, nrows = 200000\n\t#dat = dat[1:20000,]\n\t#dat = dat[dat$CHROM == 22,]\n\n\t# determine color for each of the comp methods\n\tif(trait_name == \"resid_stand\"){pretty_name = \"Residual score\"}\n\tif(trait_name == \"ratio_stand\"){pretty_name = \"Ratio score\"}\n\tif(trait_name == \"diff_stand\"){pretty_name = \"Difference score\"}\n\n\t# set up to save plot\n\tfileName <- paste0(\"/CCACE_Shared/Anna_F/BrainAtrophy/data/QQeval_\",trait_name,\".png\")\n\tpng(filename = fileName, width = 1000, height=1000, units=\"px\")\n\n\t\tlayout_matrix <- matrix(c(1,3,5,2,4,6), ncol=2, nrow=3)\n\t\tlayout(layout_matrix,  widths = 1:1:1:1:1:1) #heights = 1.5:1,\n\t\tpar(mar=c(5, 4, 4, 2))\n\t\tpar(oma = c(3,3,3,3))\n\n\n\t## PLOT 1: all SNPs\n\t### Calculate Genomic Inflation factor\n\tchisq <- qchisq(1-dat$P,1)\n\tlambda <- median(chisq)/qchisq(0.5,1)\n\n\t# make qq plot\n\tmain <- paste0(\"All SNPs: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat), \" SNPs\")\n\tp1 <- qq(dat$P, main = main, cex = 1, cex.axis = 1.5)\n\n\t###############################\n\t## PLOT 2: Apply INFO and MAF filter\n\tdat2 = dat[dat$MAF > 0.01,]\n\tdat2 = dat2[dat2$INFO > 0.8,]\n\n\t### Calculate Genomic Inflation factor\n\tchisq <- qchisq(1-dat2$P,1)\n\tlambda <- median(chisq)/qchisq(0.5,1)\n\n\t# make qq plot\n\tmain <- paste0(\"SNPs passing INFO > 0.9 & MAF > 0.01 filters:\\n\", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat2), \" SNPs\")\n\tp2 <- qq(dat2$P, main = main, cex = 1, cex.axis = 1.5)\n\n\t###############################\n\t## PLOT 3: HapMap3 SNPs only\n\thm3 <- \"eur_w_ld_chr/w_hm3.snplist\"\n\thm3SNPs <- fread(hm3)\n\tnames(hm3SNPs) <- c(\"ID\", \"ALLELE1\", \"ALLELE0\")\n\n\t# merge the two data sets and only keep overlapping SNPS that agree in A1 and A2\n\tdat2 <- merge(dat, hm3SNPs, by = \"ID\")\n\n\t### Calculate Genomic Inflation factor\n\tchisq <- qchisq(1-dat2$P,1)\n\tlambda <- median(chisq)/qchisq(0.5,1)\n\n\t# make qq plot\n\tmain <- paste0(\"HapMap3 SNPs: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat2), \" SNPs\")\n\tp3 <- qq(dat2$P, main = main, cex = 1, cex.axis = 1.5)\n\t\n\t###############################\n\t## PLOT 4: 1000 Genomes SNPs only\n\t# different reference files: this one is from FUMA website\n\tref = \"1KGphase3EURvariants.txt.gz\"\n\tref1000 <- fread(ref, select = c(\"SNP\", \"A1\", \"A2\"))\n\tnames(ref1000) <- c(\"ID\", \"ALLELE1\", \"ALLELE0\")\n\n\t# merge the two data sets and only keep overlapping SNPS that agree in A1 and A2\n\tdat2 <- merge(dat, ref1000, by = \"ID\")\n\n\t### Calculate Genomic Inflation factor\n\tchisq <- qchisq(1-dat2$P,1)\n\tlambda <- median(chisq)/qchisq(0.5,1)\n\n\t# make qq plot\n\tmain <- paste0(\"1000 Genomes SNPs: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat2), \" SNPs\")\n\tp4 <- qq(dat2$P, main = main, cex = 1, cex.axis = 1.5)\n\t\n\t###############################\n\t## PLOT 5: HapMap3 SNPs removed\n\t# isolate SNPs not shared between data and hm3\n\tnotHm3 = setdiff(dat$ID, hm3SNPs$ID)\n\n\t# only retain those \n\tdat2 <- dat[dat$ID %in% notHm3,]\n\t\n\t### Calculate Genomic Inflation factor\n\tchisq <- qchisq(1-dat2$P,1)\n\tlambda <- median(chisq)/qchisq(0.5,1)\n\n\t# make qq plot\n\tmain <- paste0(\"All SNPs that are not HapMap3: \", pretty_name, \" (Lambda = \", round(lambda, digits = 3), \")\\n\", nrow(dat2), \" SNPs\")\n\tp5 <- qq(dat2$P, main = main, cex = 1, cex.axis = 1.5)\n\n\t# save\n\tdev.off()\n}\n```\n\n![](images/QQeval_resid_stand.png){fig-align=\"center\"}\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":"html","warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"GWAS.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","theme":"journal","title":"Genome-wide association study","author":"Anna Elisabeth Furtjes","date":"`r format(Sys.time(), '%d %B %Y')`","doi":"test"},"extensions":{"book":{"multiFile":true}}}}}